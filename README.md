# AImancala

Main project video: 
Networking video:  https://youtu.be/r1ZySx5sYjo

<h2>Brief description of the Game</h2>
        	Mancala is a two-player game, each player has 6 pockets facing them and one mancala at their right. Each pocket is filled with 4 stones at the beginning of the game, and the player that starts the game chooses one pocket on their side of the board to take all the stones that it acquires and distribute them in the neighboring pockets in an anti-clockwise direction, one stone in each pocket.
The player can put the balls in their pockets, mancala, or the opponent’s pockets but they’re not allowed to place them in the opponent’s mancala. If the last piece a player drops is in their mancala, they get to play again for another turn. The game has two modes: With stealing and without stealing. Stealing means that if the last piece a player drops is in an empty pocket on their side, they’ll capture that piece and any piece in the hole directly opposite to it.
The main goal is to collect the most stones, so any piece you collect you need to place in your mancala. The game ends when one side has all their pockets empty. The player that still has stones in their pockets takes all these pieces and puts them into their mancala. Count all the pieces in the mancala and the player with the most stones wins.
<h2>Implementation</h2>
        	We’ve created two main classes: AI and GAME. The AI class is responsible for the AI player that plays against the human in the console, including a function to calculate all possible moves that could result from the current board and the minimax function that creates a tree and uses DFS to implement the alpha-beta pruning to return the board that would lead to the best score. Regarding the Game class it contains the initialization of the board and the print in console function. 
Possible_moves function: it takes two parameters: a value to indicate which player’s turn it is and the current board. The board is made of a list of two players, from index 0 to 6 is the first player with index 6 being the mancala, and from index 7 to 13 it’s the second player, mancala in indes 13. We give each player a turn flag to identify them, player 1 -mainly the human player- has flag of 0 for the first part of the list and player two -mainly the AI player- takes the flag of 1. The function takes the current board and returns a dictionary of all possible moves that could come out of this board, depending on the player. The key of the dictionary is the board and the value is which turns follows this board. Meaning, if this board would result in the current player to move another move, we save that as the value of the board in the dictionary. This function goal is to get all the leafs of each node in the tree by predicting all possible moves. 
Minimax Function : It takes multiple parameters including the mode of game whether stealing or not and the current board to build a tree with all possible states(moves on the board) keeping track if any possible move could be excluded because of cutoff till reaching a certain depth which indicates the difficulty of the game or reaching that this move is the last move on the board, and we have a winner.
First, the turn of the player determines whether the starting of estimation the sequence of the game play is maximizing or minimizing , if it is the AI’s turn it will act as maximizer and if it is the human turn it will act as minimizer .  for maximizer turn , we start with initial alpha which value is initially equal negative infinity till reaching the wanted depth then calculating the heuristic score for this move in this depth and return to the previous move to check the score with alpha if it larger then it will update it , keep checking every move in this level and getting its score , if it is larger than previous move score it update the alpha and so on , for each move I check if alpha is greater than beta so we cutoff and not complete investigating other moves in this level and return to the above depth. We keep track of every move with its heuristic score till reaching the best path for each maximizer and minimizer.
 For minimizer turn , we start with initial beta which value is initially equal infinity till reaching the wanted depth then calculating the heuristic score for this move in this depth and return to the previous move to check the score with beta if it smaller then it will update it , keep checking every move in this level and getting its heuristic score , if it is smaller than previous move score it update the beta and so on , for each move I check if alpha is greater than beta so we cutoff and not complete investigating other moves in this level and return to the above depth.   
We keep tracking for every move and the turn for whom player to play now.
For minimax client-server : the only change from the previous algorithm is both AI play vs each other so both are maximizer , so for the server will use Minimax_alphabeta function  and for the client Minimax_alphabeta_client , the only change is that we change the player turn flag that indicate the maximizer turn to be = 0 not  =1 as it in the Minimax_alphabeta function.
